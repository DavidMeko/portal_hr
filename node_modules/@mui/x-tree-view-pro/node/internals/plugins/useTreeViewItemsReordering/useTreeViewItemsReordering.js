"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTreeViewItemsReordering = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _internals = require("@mui/x-tree-view/internals");
var _useTreeViewItemsReordering = require("./useTreeViewItemsReordering.utils");
var _useTreeViewItemsReordering2 = require("./useTreeViewItemsReordering.itemPlugin");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const useTreeViewItemsReordering = ({
  params,
  instance,
  state,
  setState,
  experimentalFeatures
}) => {
  const isItemsReorderingEnabled = params.itemsReordering && !!experimentalFeatures?.itemsReordering;
  if (process.env.NODE_ENV !== 'production') {
    if (params.itemsReordering && (!experimentalFeatures?.indentationAtItemLevel || !experimentalFeatures?.itemsReordering)) {
      (0, _internals.warnOnce)(['MUI X: The items reordering feature requires the `indentationAtItemLevel` and `itemsReordering` experimental features to be enabled.', 'You can do it by passing `experimentalFeatures={{ indentationAtItemLevel: true, itemsReordering: true }}` to the `RichTreeViewPro` component.', 'Check the documentation for more details: https://mui.com/x/react-tree-view/rich-tree-view/items/']);
    }
  }
  const canItemBeDragged = React.useCallback(itemId => {
    if (!isItemsReorderingEnabled) {
      return false;
    }
    const isItemReorderable = params.isItemReorderable;
    if (isItemReorderable) {
      return isItemReorderable(itemId);
    }
    return true;
  }, [isItemsReorderingEnabled, params.isItemReorderable]);
  const getDroppingTargetValidActions = React.useCallback(itemId => {
    if (!state.itemsReordering) {
      throw new Error('There is no ongoing reordering.');
    }
    if (itemId === state.itemsReordering.draggedItemId) {
      return {};
    }
    const canMoveItemToNewPosition = params.canMoveItemToNewPosition;
    const targetItemMeta = instance.getItemMeta(itemId);
    const targetItemIndex = instance.getItemIndex(targetItemMeta.id);
    const draggedItemMeta = instance.getItemMeta(state.itemsReordering.draggedItemId);
    const draggedItemIndex = instance.getItemIndex(draggedItemMeta.id);
    const oldPosition = {
      parentId: draggedItemMeta.parentId,
      index: draggedItemIndex
    };
    const checkIfPositionIsValid = positionAfterAction => {
      let isValid;
      // If the new position is equal to the old one, we don't want to show any dropping UI.
      if (positionAfterAction.parentId === oldPosition.parentId && positionAfterAction.index === oldPosition.index) {
        isValid = false;
      } else if (canMoveItemToNewPosition) {
        isValid = canMoveItemToNewPosition({
          itemId,
          oldPosition,
          newPosition: positionAfterAction
        });
      } else {
        isValid = true;
      }
      return isValid;
    };
    const positionsAfterAction = {
      'make-child': {
        parentId: targetItemMeta.id,
        index: 0
      },
      'reorder-above': {
        parentId: targetItemMeta.parentId,
        index: targetItemMeta.parentId === draggedItemMeta.parentId && targetItemIndex > draggedItemIndex ? targetItemIndex - 1 : targetItemIndex
      },
      'reorder-below': targetItemMeta.expandable ? null : {
        parentId: targetItemMeta.parentId,
        index: targetItemMeta.parentId === draggedItemMeta.parentId && targetItemIndex > draggedItemIndex ? targetItemIndex : targetItemIndex + 1
      },
      'move-to-parent': targetItemMeta.parentId == null ? null : {
        parentId: targetItemMeta.parentId,
        index: instance.getItemOrderedChildrenIds(targetItemMeta.parentId).length
      }
    };
    const validActions = {};
    Object.keys(positionsAfterAction).forEach(action => {
      const positionAfterAction = positionsAfterAction[action];
      if (positionAfterAction != null && checkIfPositionIsValid(positionAfterAction)) {
        validActions[action] = positionAfterAction;
      }
    });
    return validActions;
  }, [instance, state.itemsReordering, params.canMoveItemToNewPosition]);
  const startDraggingItem = React.useCallback(itemId => {
    setState(prevState => (0, _extends2.default)({}, prevState, {
      itemsReordering: {
        targetItemId: itemId,
        draggedItemId: itemId,
        action: null,
        newPosition: null
      }
    }));
  }, [setState]);
  const stopDraggingItem = React.useCallback(itemId => {
    if (state.itemsReordering == null || state.itemsReordering.draggedItemId !== itemId) {
      return;
    }
    if (state.itemsReordering.draggedItemId === state.itemsReordering.targetItemId || state.itemsReordering.action == null || state.itemsReordering.newPosition == null) {
      setState(prevState => (0, _extends2.default)({}, prevState, {
        itemsReordering: null
      }));
      return;
    }
    const draggedItemMeta = instance.getItemMeta(state.itemsReordering.draggedItemId);
    const oldPosition = {
      parentId: draggedItemMeta.parentId,
      index: instance.getItemIndex(draggedItemMeta.id)
    };
    const newPosition = state.itemsReordering.newPosition;
    setState(prevState => (0, _extends2.default)({}, prevState, {
      itemsReordering: null,
      items: (0, _useTreeViewItemsReordering.moveItemInTree)({
        itemToMoveId: itemId,
        newPosition,
        oldPosition,
        prevState: prevState.items
      })
    }));
    const onItemPositionChange = params.onItemPositionChange;
    onItemPositionChange?.({
      itemId,
      newPosition,
      oldPosition
    });
  }, [setState, state.itemsReordering, instance, params.onItemPositionChange]);
  const setDragTargetItem = React.useCallback(({
    itemId,
    validActions,
    targetHeight,
    cursorY,
    cursorX,
    contentElement
  }) => {
    setState(prevState => {
      const prevSubState = prevState.itemsReordering;
      if (prevSubState == null || (0, _useTreeViewItemsReordering.isAncestor)(instance, itemId, prevSubState.draggedItemId)) {
        return prevState;
      }
      const action = (0, _useTreeViewItemsReordering.chooseActionToApply)({
        itemChildrenIndentation: params.itemChildrenIndentation,
        validActions,
        targetHeight,
        targetDepth: prevState.items.itemMetaMap[itemId].depth,
        cursorY,
        cursorX,
        contentElement
      });
      const newPosition = action == null ? null : validActions[action];
      if (prevSubState.targetItemId === itemId && prevSubState.action === action && prevSubState.newPosition?.parentId === newPosition?.parentId && prevSubState.newPosition?.index === newPosition?.index) {
        return prevState;
      }
      return (0, _extends2.default)({}, prevState, {
        itemsReordering: (0, _extends2.default)({}, prevSubState, {
          targetItemId: itemId,
          newPosition,
          action
        })
      });
    });
  }, [instance, setState, params.itemChildrenIndentation]);
  return {
    instance: {
      canItemBeDragged,
      getDroppingTargetValidActions,
      startDraggingItem,
      stopDraggingItem,
      setDragTargetItem
    },
    contextValue: {
      itemsReordering: {
        enabled: isItemsReorderingEnabled,
        currentDrag: state.itemsReordering
      }
    }
  };
};
exports.useTreeViewItemsReordering = useTreeViewItemsReordering;
useTreeViewItemsReordering.itemPlugin = _useTreeViewItemsReordering2.useTreeViewItemsReorderingItemPlugin;
useTreeViewItemsReordering.getDefaultizedParams = params => (0, _extends2.default)({}, params, {
  itemsReordering: params.itemsReordering ?? false
});
useTreeViewItemsReordering.getInitialState = () => ({
  itemsReordering: null
});
useTreeViewItemsReordering.params = {
  itemsReordering: true,
  isItemReorderable: true,
  canMoveItemToNewPosition: true,
  onItemPositionChange: true
};